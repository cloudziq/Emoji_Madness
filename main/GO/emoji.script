go.property("speed",  5.88)
go.property("wait",   3.46)
go.property("score",  4)
go.property("dest",   vmath.vector3())


emojis = 10 ; level = 1  -- dummy values, will be overwriten anyway


-- local functions:
local get_new_menu_emoji_pos, get_new_emoji_pos, emoji_waiting, sprite_flip


-- local hashes:
local collide_contact_hash = hash("contact_point_response")
local collide_weapon_hash  = hash("weapon")
local hash_right_click     = hash("menu_right_click")




function init(self)
	self.active         = true
	self.delay          = rnd.range(2, (emojis / 3) - (level / 2.8))
	self.wait_timeout   = 0
	self.waiting        = false
	self.going_away     = false
	self.need_pos_check = false
	self.sound_delay    = 0
	self.collide_type   = 0
	self.particle_url   = msg.url(nil, go.get_id(), "particle")

	msg.post("#sprite", "play_animation", {id = hash("e"..rnd.range(1, emoji_in_atlas))})

	-- emojis for main menu
	if bonus_level_active ~= 1 then
		if main_menu_visible then
			msg.post("#collide_emoji", "disable")
			particlefx.play(self.particle_url)
			sprite.set_constant("#sprite", "tint", vmath.vector4(.62, .76, .82, 1))
			timer.delay(1.84, false, function() msg.post("#collide_emoji", "enable") end)
			go.set_scale(math.random(36, 360) / 100)
			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, 1.2, go.EASING_INOUTSINE, 1.5, rnd.range(6, 14) / 10)
			get_new_menu_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE)
		else
			self.collide_url = msg.url(nil, go.get_id(), "collide_emoji")
			sprite.set_constant("#sprite", "tint", vmath.vector4(1,1,1,1))
			get_new_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE, self.delay)
		end
	else
		sprite.set_constant("#sprite", "tint", vmath.vector4(1,1,1,0))
		self.collide_url = msg.url(nil, go.get_id(), "collide_emoji")
		self.sprite_url = msg.url(nil, go.get_id(), "sprite")
	end
end




function update(self, dt)
	local pos, pos_x, pos_y
	if bonus_level_active ~= 1 then

		-- disable emojis at the end of main menu
		if main_menu_visible == true then
			if allow_title_emojis == false and self.active == true then
				self.active = false
				msg.post(msg.url(nil, go.get_id(), "collide_emoji"), "disable")

				pos = go.get_position()
				pos_x, pos_y = get_offscreen_pos(400, true, pos)
				go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, math.random(36, 360) / 100, go.EASING_INOUTSINE, 1.5, rnd.range(6, 14) / 10)
				go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(pos_x, pos_y, 1), go.EASING_INOUTSINE, 1.5, rnd.range(6, 14) / 10, function ()
					go.delete()
				end)
			end

		-- checks if emoji is on-screen, to determine if it can go to waiting state, if not - get new on-screen position
		else
			pos = go.get_position()

			if pos.x > 50 and pos.x < window_w - 50 and pos.y > 50 and pos.y < window_h -50 - 44 and self.active == true and self.going_away == false then
				self.need_pos_check = false
				--msg.post(self.collide_url, "enable")
			else
				self.need_pos_check = true
				--msg.post(self.collide_url, "disable")
			end
		end
	end
end




function get_new_menu_emoji_pos(self, easing1, easing2)
	local pos_x, pos_y
	local radius, x, y

	radius = rnd.range(40, 160)
	time = rnd.range(2, 12)

	pos_x = rnd.range(50 + 20, window_w - 20 - 50)
	pos_y = rnd.range(50 + 20, window_h - 20 - 50)
	self.dest = vmath.vector3(pos_x, pos_y, 1)
	sprite_flip(pos_x)

	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, pos_y, easing1, time)
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x - radius, easing2, time * 0.5, 0, function()
		go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x, easing2, time * 0.5, 0, function()
			if allow_title_emojis == true then get_new_menu_emoji_pos(self, 0, easing1, easing2) end
		end)
	end)
end




function get_new_emoji_pos(self, easing1, easing2, delay)
	if self.active == true then
		local pos_x, pos_y
		local radius, x, y
		local dist_add = bonus_level_active == 1 and 50 or 0

		if bonus_level_active == 1 then self.active = false end

		radius = rnd.range(40, 160)

		if not self.going_away then
			time = self.speed - (self.speed * (speed / 100)) + math.random(-2, 4)
			pos_x = rnd.range(80 + 50, window_w - 80 - 50)
			pos_y = rnd.range(80 + 50, window_h - 120 - 50)
			self.dest = vmath.vector3(pos_x, pos_y, 1)
		else
			time = (self.speed - (self.speed * (speed / 100))) * 1.82
			pos_x, pos_y = get_offscreen_pos(100 + dist_add, true, go.get_position())
		end
		sprite_flip(pos_x)

		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, pos_y, easing1, time, delay)
		go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x - radius, easing2, time * 0.5, delay, function()
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x, easing2, time * 0.5, 0, function()
				if not self.going_away then
					self.need_pos_check = false
					emoji_waiting(self)
				else
					if health > 0 and bonus_level_active ~= 1 and self.active then
						sound.play("game_layer1:/main#energy_loss", {speed = math.random(80, 120) / 100})
						emojis_left = emojis_left - 1 ; escaped = escaped + 1
						health = health - 1
						msg.post("game_layer2:/main#game_gui", "display_update", {stat = "emoji_left"})
					end
					particlefx.stop(self.particle_url)
				end
			end)
		end)
	end
end




function emoji_waiting(self)
	if self.active == true then
		if self.wait_timeout == 0 then
			self.wait_timeout = (self.wait - (self.wait * speed / 100)) + math.random(-1, 8) + socket.gettime()
			self.waiting = true
			self.score = self.score / 2
			particlefx.play(self.particle_url)
			particlefx.set_constant(self.particle_url, "emitter", "tint", vmath.vector4(.28, .32, .62, .6))
			particlefx.set_constant(self.particle_url, "emitter_light", "tint", vmath.vector4(.52, .56, .78, .84))
		end

		if socket.gettime() >= self.wait_timeout and self.going_away == false then
			if bonus_level_active == 1 then particlefx.play(self.particle_url) end
			msg.post(self.collide_url, "disable")
			particlefx.set_constant(self.particle_url, "emitter", "tint", vmath.vector4(1, .6, .2, .68))
			particlefx.set_constant(self.particle_url, "emitter_light", "tint", vmath.vector4(1, .74, .44, .96))

			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, go.get_scale() * 1.32, go.EASING_INSINE, .44, 0, function()
				self.waiting = false
				self.going_away = true
				self.score = self.score / 2
				sound.play("game_layer1:/main#emoji_going_away", {speed = (math.random(80, 120) / 100) * proxy_speed})
				get_new_emoji_pos(self, go.EASING_INSINE, go.EASING_LINEAR, .1)
			end)
		else
			local pos = go.get_position()
			pos.x = pos.x + math.random(-22, 22) ; 	pos.y = pos.y + math.random(-22, 22)
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_INOUTSINE, math.random(2, 4), 0, function()
				if self.going_away == false then
					emoji_waiting(self)
				end
			end)
		end
	end
end




function sprite_flip(pos)
	sprite.set_hflip(".", go.get_position().x < pos)
end




function on_message(self, message_id, message, sender)
	local a, z, id, pos, pos_x, pos_y, force, distance, time, play_sound, multiplier, combo_charged
	local blood_scale = {20, 15, 60, 45}


	-- for main menu
	if main_menu_visible == true then


		if message_id == collide_contact_hash and self.active == true then
			pos = go.get_position()

			if self.collide_type == 0 then
				if math.random(1, 400) <= 360 then
					self.collide_type = 1
					particlefx.set_constant(self.particle_url, "emitter", "tint", vmath.vector4(.52, .56, .78, .84))
					particlefx.set_constant(self.particle_url, "emitter_light", "tint", vmath.vector4(.52, .56, .78, .84))
				else
					self.collide_type = 2
					particlefx.set_constant(self.particle_url, "emitter", "tint", vmath.vector4(1, .6, .2, .68))
					particlefx.set_constant(self.particle_url, "emitter_light", "tint", vmath.vector4(1, .74, .44, .96))
				end
			end

			if self.collide_type == 1 then
				force = rnd.range(44, 88) / 10
				distance = rnd.range(8, 26)
				time = rnd.range(18, 40) / 10
				self.dest = pos + (message.normal * force) * (message.distance * distance)
				self.collide = -1
				go.cancel_animations(".", "position")
			elseif self.collide_type == 2 then
				force = 1
				distance = 1.2
				time = rnd.range(18, 36) / 10
				self.collide = -1
			end


			if message.group == hash_right_click then
				force = 20
				distance = rnd.range(10, 36) / 10
				time = rnd.range(10, 24) / 10
				--self.collide = 0
				self.dest = pos + (message.normal * force) * (message.distance * distance)


			elseif message.group == hash("emoji") then
				other_dest = go.get(msg.url(nil, message.other_id, "emoji"), "dest")

				if self.dest.x < other_dest.x + 60 and self.dest.x > other_dest.x - 60 then
					self.dest.x = pos.x
				end
				if self.dest.y < other_dest.y + 60 and self.dest.y > other_dest.y - 60 then
					self.dest.y = pos.y
				end
			end

			go.set_position(pos + message.normal * message.distance) ; sprite_flip(pos.x)
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, self.dest, go.EASING_OUTSINE, time, 0, function()
				self.collide_type = 0
				get_new_menu_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE)
			end)
		end




	-- for levels
	else
		if bonus_level_active ~= 1 then
			local sound_type, sound_speed

			if message.group == collide_weapon_hash and self.active == true then

				if score > 0 then score = score + bullet_miss end
				emojis_left = emojis_left - 1
				killed = killed + 1
				combo_charged = false
				score = score + self.score

				if emojis_left > 0 then
					sound_speed = (math.random(60, 120) / 100)
				else
					sound_speed = (math.random(16, 24) / 100)
				end

				if self.going_away then
					sound.stop("game_layer1:/main#emoji_going_away")
					sound_type = "game_layer1:/main#squeak_big"
					combo_charged = true
				else
					sound_type = "game_layer1:/main#squeak_small"
				end
				msg.post(weapon_id, "count charged_kill", {score = self.score, charged = combo_charged})

				sound.play(sound_type, {speed = sound_speed * proxy_speed, gain = math.random(80, 120) / 100 })
				msg.post("game_layer2:/main#game_gui", "display_update")
				particlefx.stop(self.particle_url)

				self.active = false
				msg.post(self.collide_url, "disable")

				go.cancel_animations(".", "position")
				go.cancel_animations(".", "scale")
				pos = go.get_position()
				go.set_position(vmath.vector3(pos.x, pos.y, .8))
				go.set_rotation(vmath.quat_rotation_z(math.random(1, 360)))
				make_blood(pos, blood_scale)




			elseif message_id == collide_contact_hash and self.active == true then
				time = rnd.range(26, 44) / 10
				time = time + (time * speed / 100)

				pos = go.get_position() + message.normal * (message.distance * 1.22)
				go.set_position(pos)

				other_dest = go.get(msg.url(nil, message.other_id, "emoji"), "dest")
				if self.need_pos_check then play_sound = false else play_sound = true end

				if self.dest.x < other_dest.x + 60 and self.dest.x > other_dest.x - 60 then
					self.dest.x = pos.x
					play_sound = false
				end
				if self.dest.y < other_dest.y + 60 and self.dest.y > other_dest.y - 60 then
					self.dest.y = pos.y
					play_sound = false
				end

				if play_sound and socket.gettime() > self.sound_delay then
					sound.play("game_layer1:/main#emoji_collide", {speed = (math.random (14, 24) / 10) * proxy_speed})
					self.sound_delay = socket.gettime() + 0.08
				end

				go.cancel_animations(".", "position")
				go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, self.dest, go.EASING_OUTSINE, time, 0, function()
					if self.need_pos_check == true then
						self.wait_timeout = 0
						--go.cancel_animations(".", "position")
						get_new_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE, 0)
					else
						emoji_waiting(self)
					end
				end)
			end




		-- bonus level handling:
		else
			if message.group == collide_weapon_hash and self.active == true then
				local sound_type, sound_speed

				self.active = false
				go.set(self.sprite_url, "tint.w", 1)
				pos = go.get_position()
				go.set_position(vmath.vector3(pos.x, pos.y, .8))

				if go.get_scale().x == 1 then
					bonus_score = bonus_score + 10
					bonus_level_kills.small = bonus_level_kills.small + 1
					make_blood(pos, blood_scale)
					sound_type = "game_layer1:/main#squeak_small"
					sound_speed = (math.random(60, 120) / 100)
				else
					bonus_score = bonus_score + 50
					bonus_level_kills.big = bonus_level_kills.big + 1
					make_blood(pos, blood_scale, 1.6)
					sound_type = "game_layer1:/main#squeak_big"
					sound_speed = (math.random(20, 35) / 100)
				end

				sound.play(sound_type, {speed = sound_speed * proxy_speed, gain = math.random(80, 120) / 100 })
				msg.post("game_layer2:/main#ctrl", "reset anim", {visible = true})
				msg.post("game_layer2:/main#game_gui", "bonus_display_update")


			elseif message_id == hash("collision_response") and self.active == true then
				if go.get_scale(".").x == 1 then multiplier = 1 else multiplier = 2 end
				pos_x, pos_y = get_onscreen_pos(10, multiplier)
				go.set_position(vmath.vector3(pos_x, pos_y, 1))
			end
		end




		if message_id == hash("clean_emojis") then
			for a = 1, table.maxn(emoji_table) do
				self.active = false
				go.animate(emoji_table[a], "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(0,0,0), go.EASING_INSINE, 2, 0, function()
					go.delete(emoji_table[a])

					if a == table.maxn(emoji_table) then
						if message.continue then
							wait_for_clean = false
						end
					end
				end)
			end




		elseif message_id == hash("bonus level emoji at end") then
			self.speed = 2
			self.wait_timeout = message.timeout
			timer.delay(message.delay, false, function()
				sound.play("/main#plumk", {gain = 0.22, speed = math.random(100, 200) / 100})
			end)
			go.animate(self.sprite_url, "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_INSINE, .2, message.delay, function()
				if self.active then emoji_waiting(self) end
			end)


			msg.post("#collide_emoji", "disable")
		end
	end
end




function make_blood(pos, blood_scale, multiplier)
	if multiplier == nil then multiplier = 1 end
	
	for a = 1, 4 do
		-- blood 1 and 2 is under sprite
		-- blood 4 is between cursor and emoji
		if a <= 2 then z = .4 else z = .9 end
		if a == 4 then
			if cursor_x > pos.x then
				pos_x = cursor_x - (cursor_x - pos.x) / 2
			elseif cursor_x < pos.x then
				pos_x = cursor_x + (pos.x - cursor_x) / 2
			else
				pos_x = pos.x
			end

			if cursor_y > pos.y then
				pos_y = cursor_y - (cursor_y - pos.y) / 2
			elseif cursor_y < pos.y then
				pos_y = cursor_y + (pos.y - cursor_y) / 2
			else
				pos_y = pos.y
			end
		else
			pos_x = pos.x + math.random(-8, 8)
			pos_y = pos.y + math.random(-8, 8)
		end

		msg.post("game_layer2:/main#ctrl", "spawn_blood", {a = a, x = pos_x, y = pos_y, z = z, scale = blood_scale[a] * multiplier, multiplier = multiplier})
	end
end
